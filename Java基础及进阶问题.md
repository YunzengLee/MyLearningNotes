### 数组初始化

int [][] arr = new int [2] [3];

int [][] arr = new int [][]{{1,2,3}，{1,2}，{1,2,3,4}}；数组长度可以不相同。

int [][] arr = new int [2] []; 这个是只制定了第一维的长度，第二维不定义。

**注意：一维数组声明时必须声明长度，二维数组同样，但是二维数组是必须声明第一维的长度，第二维的长度无要求。如果是定义为{},****就可以不声明长度，比如：**

**int[] arr = {};** **是没有问题的。**



**类中的方法可以直接访问成员变量但是有**例外：**Static方法不能访问非static的成员变量!!!只能访问static的成员变量**



### 构造器

- **子类的构造器必须先调用父类的构造器**

- **子类所有构造器默认自动调用父类空参数的构造器（所以，如果父类因为自定义了构造器而没有无参构造器时，子类就需要自己写构造器，并在构造器的首部调用父类的有参构造）**

- 由以上两点可知，若父类没有空参数构造器(可能由于自定义构造器使得无参构造器失效)，子类构造器必须显式的写至少一个构造器，且必须通过**this(参数列表)或者super(参数列表)语句**指定调用本类或父类的相应的构造器，并放在构造器第一行，否则编译出错。



### 实例初始化过程

从方法区加载class（先加载父类后加载子类）；在栈内存开辟空间声明变量；在堆内存开辟空间，存储地址；在堆内存中，在对象空间中，将对象属性初始化为默认值（先父类后子类）；调用构造方法进行初始化，子类构造方法入栈内存执行，父类构造方法入栈执行并出栈；初始化结束后，将堆内存地址赋值给引用变量，子类构造方法出栈。

### static

**1.**    因为static方法不用实例化就能调用，因此static方法内部不能有this、super。也就是不能涉及实例变量。

**2.**    **重载的方法必须同时为static或非static**。

**Static修饰的初始化块只在第一次new对象时执行一次，而其他非static修饰的代码块和构造方法都是new一次就执行一次。**





### 面向对象三大特征

- 封装：

  隐藏就是加private，这样的方法或属性只能在自己的类方法中调用。再提供public方法实现对该属性的操作。

  - 隐藏不必对外提供的细节

  - 使用者只能通过定制好的方法访问数据，可以加入控制逻辑避免不合理操作

  - 便于修改，增强代码可维护性。

- 继承

  子类含有父类的所有方法和属性（包括private属性和private方法，只是这些属性或方法无法直接访问）。子类可以根据需要对父类的方法进行改造（重写）。子类可以在父类的基础上进行扩展。

  （子类重写的方法较于父类方法：访问权限只能更大，抛出的异常范围只能更小）

- 多态

  Person p = new Student(); 父类变量可以接收子类实例对象，引用变量p**可以访问子类Studennt中的重写方法，但无法访问子类Student中的重写的属性。方法声明时形参为父类类型，可以将子类实例作为实参传入。** 方法的重载和重写是多态的另一个体现。





### 接口和抽象类的区别

1. 接口的方法默认是public，所有方法不能有实现（1.8开始婿有默认实现），抽象类可以有非抽象方法
2. 接口中只有static、final变量，而抽象类不一定。
3. 一个类可以实现多个接口，但只能继承一个类，接口本身可以通过extends扩展多个接口
4. 接口方法默认修饰符是public，抽象类的方法可以有public，protected，default三种（private修饰的无法被重写）
5. 抽象类是对类的抽象，接口是对行为的抽象

### 接口的变化

1. 7之前接口只能有常量变量和抽象方法，不能有实现
2. 8可以有default方法和static方法（也就是使用default和static修饰的方法，必须要有方法体）。
   接口中的static方法实现类无法继承，default方法实现类可以继承。default方法必须由接口实现类实例来调用，default方法可以被重写，重写后权限必须改为public。static由接口直接调用（实现类调用不到）。
3. 9可以有私有方法和静态私有方法



### final关键字

1. 修饰变量，该变量必须显式地初始化，一旦被初始化后就不能更改，引用类型的变量不能更改指向另一个对象
2. 修饰类，该类无法被继承，所有成员方法都会指定为final
3. 修饰方法，继承类无法修改。

继承了Seriable接口的类可以被序列化，给其中的变量加transient关键字可以使该变量不被序列化。

### static关键字

1. 修饰成员变量和方法：被修饰的成员属于类，可以通过类名调用，被所有实例共享，存放在方法区。
2. 修饰代码块：该代码块在非静态代码块之前执行，非静态代码块在构造方法之前执行。静态代码块只执行一次（非静态代码块每次实例化都会执行），用于初始化静态变量。
3. 修饰内部类：非静态内部类编译后保存着指向外围类的引用，而静态内部类没有，这说明：静态内部类创建不依赖于外围类的创建；不能使用外围类的非静态成员。
4. 静态导包：import static连用可以导入指定类中的静态资源，而不需要使用类名调用，可以直接使用静态成员变量和方法。

### this

1. 指当前类的实例对象，可以调用该对象的属性和方法，或者是用来区分同名形参和自身的属性。
2. 后面加括号代表该类的构造器，根据传入的参数类型和顺序决定哪个构造器，放在某个构造器的首行。

### super

1. 指父类对象，可以调用父类的属性或方法（除了私有属性和方法）
2. 后面加括号代表调用父类的构造器，一定放在自己某个构造器的首行。

### 抽象

将子类的共同特征提取到公共父类中，父类又无法给出具体的方法实现，这就是抽象。

抽象有两种：

- 抽象方法
- 抽象类

有抽象方法的类一定是抽象类。

