# JVM

一种能运行java字节码的虚拟机，jvm有很多，Hotspot是一种。

## JVM的基本结构

JVM由三个主要的子系统组成

- 类加载子系统
- 运行时数据区（内存结构）
- 执行引擎

### 运行时数据区

- 组成

  - ![1587563892063](.\JVM\运行时数据区组成.png)

  - ![1587629794222](.\JVM\每个线程的私有空间.png)
  - 堆（共享）
  - 方法区（共享）
  - 虚拟机栈（线程私有）
  - 本地方法栈
  - 程序计数器

- 程序计数器：当前线程所执行的字节码的行号指示器。**字节码解释器（在虚拟机内）通过改变这个计数器的值来选取下一条需要执行的字节码指令**。为了**线程切换后能恢复到正确的执行位置**，程序计数器为线程私有，互不影响。

  唯一不会出现OutOfMemoryError的区域。

- 虚拟机栈中含有一个个栈帧，每个栈帧就是一个方法，一个方法调用就有一个栈帧入栈，方法结束对应一个栈帧出栈。可能出现2种Error：

  - StackOverFlowError：如果虚拟机栈大小不允许动态扩展，可能出现栈溢出
  - OutOfMemoryError：如果虚拟机栈运行动态扩展，而线程请求栈时内存用完了，就会出现内存溢出

- 栈帧包含：
  - 局部变量表（随着代码进行，存放该方法出现的局部变量，包括数据类型和引用类型）
  - 操作数栈（进行计算时，会将参与计算的变量从局部变量表复制过来或从常量池弄过来，然后取出来交给引擎，得到计算结果并存入，进而根据情况再放到局部变量表）
  - 动态链接（把符号引用转为直接引用的过程）对象存在堆里，栈帧里面的局部变量表存一个对象的直接引用（也就是对象的地址），符号引用本质上就是一组符号字符串，通过字符串找堆里的对象就是链接，编译时无法找到某个对象或类的内存地址就用符号引用代替。动态是指这个过程在方法运行时出现，静态链接指编译时出现。
  - 返回地址/方法出口（用于返回值的返回）

- 本地方法栈
  
  不需要多研究，与虚拟机栈类似，但是是用来存放native修饰的本地方法的。本地方法是java底层的c或c++写的方法
  
- 方法区
  
  用于存放：定义的**方法信息、静态变量+常量+已加载的类信息（构造方法/接口定义）+运行时常量池**，位于本地内存（就是自己的内存条，也叫堆外内存）（方法区只是虚拟机规范定义的概念并说明了作用，不同的JVM上对方法区的实现方式不同。1.8以前叫持久代或永久代，1.8时叫元空间）
  
  - 为什么将永久代替换为元空间？
  
    其中一个原因是：永久代是由JVM来设置固定的大小上限，无法调整；而元空间使用直接内存，只受本机内存的大小限制，当然也可以设置元空间的初始大小和最大大小。
  
  - 运行时常量池
  
    方法区的一部分。class文件中除了类的版本、字段、方法、接口等描述信息外，还有常量池信息（存放编译期生成的**字面量和符号引用**）
  
    JDK1.7及以后的JVM将运行时常量池从**方法区**移出，在**堆**中开辟了一块区域存放。
  
- 堆
  - 概述：虚拟机启动时自动创建，存对象的实例，几乎所有对象都在堆上分配内存，当对象无法在该空间申请到内存时抛出OutOfMemoryError异常，是垃圾回收的主要区域。
  - ![1587562945134](.\JVM\1587562945134.png)
  - 新生代（Young Generation）  占1/3
    - Eden  1/3 * 8
      - 用于放新建对象，但不是全部，比较大的对象会直接放在老年代里
      - Eden区放满后GC，GC分两种
        - Young GC（MinorGC）：新生代产生的GC，执行时间相当短，效率相当高
          - Eden区满后执行GC，引用计数为0的清除，存活的对象放到From Survivor区，Eden区的对象年龄为0，进入From区后年龄为1
          - Survivor区分为From和To
          - Survivor区的对象有个年龄，到15就进入老年代
          - From满后也会GC回收，剩下的对象转移到To Survivor区，此时To就变成了From，而From就变成了To。经过这样一次转换的对象的年龄加1。
          - 如果Survivor区中所有相同年龄的对象所占大小大于Survivor空间的一半，年龄大于等于该年龄的对象将直接进入老年代。
          - From和To之间的转换是因为：对象在堆内的存储，经过垃圾回收后，是不连续的，对象之间有空间，但是又放不下大的对象，因此需要整理。整理方式就是把对象从From移到To，这样对象的存储就是连续的了。
          - 当To区没有足够空间存放上一次收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代，大对象和长期存活的对象也会直接进入老年代。
        - Full GC（MajorGC）：老年代满后进行FullGC，这个比较恐怖，不同的垃圾回收器一般都有一个过程叫STW（StopTheWorld），会暂停所有线程，专门执行垃圾回收，因为线程一跑就会产生垃圾。调优的两个重要指标就是减少FullGC的时间和次数。
    - From Survivor（S0区）  1/3 * 1
    - To Survivor（S1区）      1/3 * 1
  - 老年代（Old Generation）  占2/3
  - 元空间（Meta Data）：不是堆内存，但是在逻辑结构上属于堆。（方法区就是元空间。方法区是规范是标准，元空间是具体实现）

说一说GC



#### 内存分析指令

- ![1587564414849](.\JVM\JVM分析指令1.png)

- jps：显示当前所有进程，及其对应的进程id（？不确定数字代表啥）

- Jstat：显示某个进程的内存使用情况

  - S0 S1分别代表From和To
  - C代表分配大小，U代表已使用的大小
  - E O 分别代表Eden和老年代
  - YGC和FGC代表两种GC的次数  YGCT代表GC的执行时间，GCT代表GC总时间

- Jmap：可以导出dump文件，该文件是堆内存快照，可以保存在某一时刻堆的所有情况，进一步可以使用JDK或商业工具进行分析。

  - ![1587565671174](.\JVM\jmap指令.png)

  - 设置内存溢出时自动导出，是在idea的【JVM参数】中设置的，在IDEA的Run/DebugConfigurations中的OutOfMemoryDump，下的Configuration下的VM options设置以上参数。
  - 输出路径下产生一个dump文件，可以使用java的jdk/bin下的jvisualvm.exe【装入】这个dump文件进行分析。

- Jstack

  - ![1587565344498](.\JVM\JVM分析指令jstack.png)

  - 在idea中跑一个死锁程序，然后执行上述命令，就可以导出死锁进程的相应文件。



## 对象创建过程

1. 类加载检查：当JVM遇到new指令时先检查这个指令的参数是否能在常量池定位到这个类的符号引用，并检查这个类是否加载过

2. 分配内存：从堆中划分一块空间。有两种方式，取决于Java堆是否规整，是否规整又由垃圾收集算法决定。

   - 指针碰撞：已使用的内存和未使用的内存之间有一个分界指针，将该指针向未使用内存方向移动对象内存大小的位置即可。（堆内存规整）
   - 空闲列表：虚拟机维护一个记录着可用内存块的列表，找出一块划分给对象实例，之后更新列表。（堆内存不规整）

   内存分配的并发问题解决（两种方式）：

   - CAS+失败重试
   - TLAB：为每个线程预先在Eden分配一块内存称为TLAB（ThreadLocalAllocationBuffer），首先在TLAB中为对象分配内存，TLAB内存不够时再进行CAS分配。

3. 初始化零值：将分配到的内存空间都初始化为零值（不包括对象头）

4. 设置对象头：对象头存储的是：这个对象属于哪个类，对象的哈希码，对象的GC年龄等。

5. 执行构造方法：把对象按照程序员的意愿进行初始化。

### 对象的访问定位

1. 使用句柄：

   堆划分出一块区域作为句柄池，引用类型变量存放对象的句柄地址，而句柄包含了对象实例数据与类数据的具体地址信息。（好处：对象移动时只改变句柄信息，不用改变变量本身）

2. 直接指针：变量中存放的是对象的内存地址（好处：速度快，节省了一次指针定位的时间）

## 类加载机制

### 类的生命周期*

![1587629973043](.\JVM\类的生命周期.png)

#### 1. 加载

通过类加载器将.class文件从磁盘读到内存，将这些静态数据结构换成方法区中的运行时数据结构。在堆中生成一个代表这个类的java.lang.Class对象作为方法区类数据的访问入口。

通过一个类的全限定类名获取定义此类的二进制字节流，将这个字节流所代表的的静态存储结构转化为方法区域运行时数据结构，在java堆中生成一个java.lang.Class对象作为方法区类数据的访问入口。

#### 2. 连接

1. 验证：验证字节码文件的正确性，保证Class文件的字节流包含的信息符合JVM规范，不会给JVM造成危害。验证失败则抛出一个VerifyError异常。
2. 准备：给类的静态变量分配内存并赋予默认值。
3. 解析：类装载器装入类所引用的其他所有类。也就是静态链接过程，将常量池内的类的符号引用转为直接引用

#### 3. 初始化

为类的静态变量赋予正确的初始值，上述的准备阶段是为静态变量赋予默认值，此处赋予的才是程序编写者为变量分配的初始值，执行静态代码块

#### 4. 使用

#### 5. 卸载

### 类加载器的种类

除了第一个，其他都继承自java.lang.ClassLoader.

#### 启动类加载器 

BooststrapClassLoader

加载JRE的核心类库，如JAVA_HOME\lib目录下的类库。这个是用c++实现的，因为有一些c语言的包要加载。无法被JAva程序直接引用。以下几种都可以被开发者直接使用。

#### 扩展类加载器

ExtensionClassLoader

负责加载JRE扩展目录lib/ext中的类库

#### 应用程序类加载器

AppClassLoader

负责加载ClassPath路径下的类包，（自己定义的类）

#### 用户自定义加载器

用于加载用户自定义路径下的类包（用的很少）

![1587631160793](.\JVM\各种类加载器.png)

### 类加载机制

#### 全盘负责委托机制

当一个类加载器加载一个类时，除非显式的使用另一个类加载器，否则该类**所依赖和引用的类**也由这个类加载器载入。（比如当前类定义的方法中new 了一个实例，就用当前类使用的类加载器进行加载）

#### 双亲委派机制*

一个类加载器收到了类加载的请求不会自己尝试加载，而是找父加载器去完成， 当父加载器表示无法加载这个类时，子类才尝试自己去加载

如上图，先委托父类加载器寻找目标类，在找不到的情况下在自己的路径中查找并载入目标类。

解释：上层是下层的父类，一个类先被交给底层的加载器，但是不加载，而是直接向上层委托，到最上一层时做判断，是否由当前类加载器加载，如果不是就交给下层，由下一层再进行判断是否加载，直到加载成功。（也就是说，先将类传到顶层，然后从上到下逐层判断是否由当前类加载器加载）

##### 优势

- 沙箱安全机制：比如自己写的String类不会被加载，可以避免核心库被篡改
- 避免类的重复加载：当父ClassLoader加载了该类的时候，子ClassLoader就不需要再加载了,不会出现相同的类文件被不同的类加载器加载。
- 注意：tomcat和mysql的连接里就打破了这个双亲委派机制。tomcat有自己的类加载机制。

#### 缓存机制

保证加载过的class被缓存，当用到一个class时先从缓存区去搜，不存在的话再去读取二进制数据转化为对象，然后再存入缓冲区。所以后端修改了class之后需要重启。

### GC算法和收集器

参考《深入理解java虚拟机》第二版

#### 如何判断对象可以回收

堆里面存放着几乎所有对象实例，如何判断哪些需要回收？

- 引用计数法

  - 给对象添加一个引用计数器，每当有一个地方引用，计数器就加一，当引用失效，计数器减一。任何时候计数器为0的对象都是不可能再被使用的。
  - 实现简单效率高，但是主流的JVM没有使用这个算法管理内存，因为它很难解决对象之间循环引用的问题。
  - 循环引用：![1587633723107](.\JVM\循环引用示例.png)



- 可达性分析算法

  - 基本思想就是通过一系列称为GC Roots的对象作为起点，从这些节点开始向下搜索，节点走过的路径称为引用链，当一个对象到GCRoots没有任何引用链相连的话，证明此对象是不可用的
- GC Roots根节点：类加载器，Thread，虚拟机栈的局部变量表，static成员，常量引用，本地方法栈的变量等等

#### 一个对象的引用类型有[四种](https://www.jianshu.com/p/70e1900c1b33)

JDK1.2 之前，一个对象只有“已被引用”和"未被引用"两种状态，这将无法描述某些特殊情况下的对象，比如，当内存充足时需要保留，而内存紧张时才需要被抛弃的一类对象。

因此有了4种引用类型。

- 强引用（默认的，最普遍，对象在虚拟机生成时的引用，不会被垃圾回收，平时见到的都是强引用）
- 软引用（软引用是用来描述一些非必需但仍有用的对象。**在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常**。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。）
- 弱引用（**无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收**。）
- 虚引用（不会决定对象的生命周期，相当于没有引用，任何时候都可能被回收）。虚引用只是提供了一种确保对象被finalize后，做某些事情的机制。虚引用必须和引用队列关联使用，垃圾回收器回收一个对象时，如果该对象有虚引用，就会在回收对象内存之前，将这个虚引用放入与其关联的引用队列中，放入引用队列的引用表示该引用对象将要被回收，如果程序发现某个虚引用被加入引用队列，就可以在引用对象的内存被回收之前做一些行动。应用场景就是用来跟踪对象被垃圾回收器回收的活动。

#### 如何判断一个常量是废弃常量

- 运行时常量池中主要被回收的是废弃的常量

- 假如在常量池中存在字符串“abc”，如果当前没有任何String对象引用该字符串常量的话，就说明该字符串是废弃常量。如果发生内存回收而且有必要的话，就会被系统清理出常量池。

  

#### 如何判断一个类是无用的类

三个条件：

- 该类所有实例都已经被回收，堆中不存在该类的任何实例
- 加载该类的类加载器被回收
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

虚拟机可以对满足上述条件的无用类进行回收，这里仅仅是“可以”，不是和对象一样必定被回收。

### 垃圾回收算法*

![1587634651683](.\JVM\垃圾回收算法.png)

#### 标记-清除算法

最基础的收集算法，分为两个阶段，首先基于上述两个方法标记出需要回收的对象，然后统一回收所有被标记的对象。它有两个不足的地方：

- 效率问题：标记和清除两个过程的效率都不高。（相对于其他算法还是较高的，因为没有对存活对象进行整理）
- 空间问题：标记清除后会产生大量不连续的碎片。

![1587634947808](.\JVM\标记清除算法.png)

#### 复制算法

为了解决效率问题，复制算法把内存分为大小相同的两块，每次只使用一块。当这一块的内存空间用完后，将存活对象复制到另一块，然后将这块空间一次清理掉。不足就是只利用了一半的空间。

![1587635278733](.\JVM\复制算法.png)

#### 标记-整理算法

根据老年代的特点提出的一种算法，过程和标记清除算法一样，但是后续步骤不是直接对可回收对象进行回收，而是让所有存活对象向一端移动，然后直接清理掉边界外的内存。

![1587635073680](.\JVM\标记整理算法.png)

#### 分代收集算法

商用虚拟机的垃圾收集器基本都采用该算法，根据对象存活周期的不同将内存分为几块，一般将java堆分为新生代和老年代，这样我们**可以根据不同代的特点选择合适的垃圾收集算法**。

在新生代中，每次收集都有大量对象死去，可以使用复制算法，只要付出少量对象的复制成本就可以完成每次垃圾收集，而老年代对象存活几率高，而且没有额外空间对他进行分配担保，就必须选择标记-整理或标记-清除算法。



#### GC调优两个指标

- 停顿时间：垃圾收集器做垃圾回收中断应用执行的时间。-xx:MaxGCPauseMillis
- 吞吐量：1-垃圾收集时间和总时间的占比（也就是程序运行时间与总时间的占比）.-xx:GCTimeRatio

## 垃圾收集器

java虚拟机规范对垃圾收集器如何实现没有任何规定，因为没有最好的垃圾收集器，只能是根据应用场景选择合适的垃圾收集器。

![1587636303698](.\JVM\各种垃圾收集器.png)

### Serial收集器

![1587642221241](.\JVM\serial收集器.png)

- 最基本，历史最悠久的收集器，单线程收集器，（使用一条垃圾收集线程完成垃圾收集工作，更重要的是它在垃圾收集过程中必须暂停其他所有工作线程（STW）直到收集结束。）
- 新生代采用复制算法，老年代采用标记-整理算法。
- 优势：**简单而高效（相比于其他收集器的单线程相比），**由于没有线程交互的开销，自然可以获得很高的单线程收集效率。该收集器在Client模式下的虚拟机是个不错的选择。
- 缺点：不能解决STW的问题。

### ParNew收集器

![1587642788090](.\JVM\ParNew收集器.png)

- 前者的多线程版本，有多条垃圾收集线程，其余行为和前者一样

- 注意：该收集器是多线程并发而不是并行，尽管如此，与前者相比还是**STW时间减少了很多**（但还是存在STW）
- 新生代复制算法，老年代标记整理算法。

### Parallel Scavenge收集器

（市面上用的最多，JDK1.8默认的）

- 类似于前者（ParNew）（示意图与前者一样）
- 关注点是**吞吐量（高效的利用CPU）**，CMS等垃圾收集器关注点更多的是用户线程的停顿时间（提高用户体验）
- 新生代复制算法，老年代标记整理算法。

### CMS收集器

![1587644158562](.\JVM\CMS收集器.png)

主要优点：并发收集，低停顿。

三个缺点：

1. 对CPU资源敏感；同时运行用户线程和垃圾收集，对硬件要求高

 	2. 无法处理浮动垃圾；用户线程在运行时产生垃圾，没有办法处理
 	3. 使用的标记-清除算法结束时会产生大量空间碎片。



### G1垃圾收集器

G1（Garbage-First）是一款面向服务器的垃圾收集器，主要针对配备多颗处理器的及大容量内存的机器，**以极高的概率满足GC停顿时间要求的同时还具备高吞吐量性能的特征**。并发量高的项目基本都是用这个，它与CMS相似，但是处理的垃圾量翻倍。

![1587691234166](.\JVM\G1收集器.png)

![1587691291220](.\JVM\G1收集器详细描述.png)

G1的三个特点：

- 并行与并发：充分利用多核cpu，缩短STW；其他某些收集器需要停顿用户线程进行GC，而G1仍可以通过并发的方式让Java程序运行

- 分代收集：保留了分代的概念。与CMS的标记清除算法不同，G1整体看是标记整理算法，局部上看是复制算法

- 可预测的停顿：一大优势，降低停顿时间是CMS与G1 的共同关注点，但G1可以建立可预测的停顿模型，可以指定停顿时间进行GC

  实现方式：后台维护一个优先列表，根据给出的停顿时间限制，优先选择回收价值最大的区域，保证了有限时间内的收集效率。



### 如何选择垃圾收集器

![1587691644565](.\JVM\如何选择垃圾收集器.png)

- GC调优

  ![1587694867725](.\JVM\GC调优步骤.png)

  - 可以使用GCeasy等工具分析log文件，得到图形化的界面去分析。在大型项目中使用。